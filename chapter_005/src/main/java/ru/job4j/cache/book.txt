 530 Часть 11. Библиотека Java
И последнее замечание: неизменяемость символьных строк в объектах типа
String означает, что содержимое экземпляра класса String не может быть из­ менено после его создания. Но переменная, объявленная как ссылка на объект типа String, может быть в любой момент изменена таким образом, чтобы указывать на другой объект типа String.
в
строке
класса
S t r i n g , не
создания
содержащий
Конструкторы символьных строк
S t r i n g
пустого объекта типа String вызывается стандартный конструктор. Например,
В
следующей
символы:
классе
поддерживается
кода создается
несколько
экземпляр
конструкторов. Для
String s = new String();
Зачастую символьные строки требуется создавать с начальными значениями.
Для этой цели в классе String предоставляются разнообразные конструкторы. В частности, для создания символьной строки, инициализируемой массивом сим­ волов, служит следующий конструктор:
String(char chars[])
Ниже приведен пример применения этого конструктора. В нем строка s иници­
ализируется символами "аЬс ". charchars[] = { 'а', 'Ь', 'с' };
String s = new String(chars);
Используя следующий конструктор, можно задать поддиапазон, т.е. определен­
ную часть массива символов для инициализации ими строки:
String(char chars[], int начальный_индекс,
i n t
количество_символов)
Здесь параметр начальный_индекс обозначает начало поддиапазона, а па­
раметр количество_символов - те символы, которые следует использовать
для инициализации строки. В следующем примере кода строка s инициализирует­ ся символами "cde":
charchars[] ={'а', 'Ь', 'с', 'd', 'е', 'f' }; String s = new String(chars, 2, 3);
Используя следующий конструктор, можно создать объект типа String, со­ держащий ту же последовательность символов, что и другой объект типа S t r i n g :
String(String строковый_объект)
Здесь параметр строковый_ объект обозначает объект типа S t r i n g . Рассмот­ рим следующий пример программы:
S t r i n g из
puЫic static void main(String args[J) {
11 Создать
class MakeString {
один объект типа
другого
 i n t
количество_символов)
Глава 17. Обработка символьных строк 531
charс[] ={'J', 'а', 'v', 'а'}; String sl = new String(c);
String s2 = new String(sl); System.out.println(sl); System.out.println(s2);
Ниже приведен результат, выводимый данной программой. Как видите, сим­
вольные строки s 1 и s 2 содержат одинаковые значения. Java
Java
Несмотря на то что в примитивном типе c h a r языка Java для представления ос­ новного набора символов в Юникоде употребляются 16 бит, в типичном формате символьных строк, пересылаемых через Интернет, используются массивы 8-раз­ рядных байтов, создаваемых из набора символов в коде ASCII. Чаще всего упо­ требляются 8-разрядные строки в коде ASCII, и поэтому в классе String предо­ ставляются конструкторы, инициализирующие символьную строку массивом типа byte. Ниже приведена общая форма этих конструкторов.
String(byte chrs[])
String(byte chrs[], int начальный_индекс,
Здесь chrs обозначает массив байтов. Вторая форма конструктора позволяет указать требуемый поддиапазон символов. В каждом из этих конструкторов пре­ образование байтов в символы выполняется в соответствии с кодировкой, выби­ раемой на конкретной платформе по умолчанию. Применение этих конструкторов демонстрируется в следующем примере программы:
11 Создать символьную строку из подмножества 11 массива символов
class SubStringCons {
puЬlic static void main(String args[]) ( byte ascii[] = (65, 66, 67, 68, 69, 70 };
String sl = new String(ascii); System.out.println(sl);
String s2 = new String(ascii, 2, 3); System.out.println(s2);
Ниже приведен результат, выводимый данной программой.
ABCDEF CDE
Имеются также расширенные версии конструкторов, где байты преобразуются
в символьные строки и можно указать кодировку символов, определяющую по­
рядок преобразования байтов в символы. Но, как правило, требуется кодировка,
выбираемая на конкретной платформе по умолчанию.

 532
Часть 11. Библиотека Java
Содержимое массива копируется всякий раз, когда объект типа S t r i n g создается из массива. Даже если содержимое массива изменится после создания символьной строки в виде объекта типа S t r i n g , последний останется без изменения.
Объект типа String можно создать из объекта типа StringBuffer, исполь­ зуя следующий конструктор:
String(StringBuffer объект_буфера_строк)
А создать символьную строку из объекта типа StringBuilder можно с по­
мощью такого конструктора:
String(StringBuilder объект_простроения_строки)
В следующем конструкторе поддерживается расширенный набор символов
в Юникоде:
String(int codePoints[], int начальный_индекс,
На заметку!
i n t
количество_символов)
Здесь codePoints обозначает массив, содержащий символы в Юникоде. Резуль­ тирующая строка создается из помиапазона символов, начало которого обозначает начальный_индекс, а длина - количество_символов. Имеются также кон­ структоры, позволяющие указывать конкретный набор символов.
На заметку! Обсуждение основных понятий и составляющих Юникода, в том числе кодовых точек,
а также обращение с ними в Java приведено в главе 18.
Длина символьной строки
Количество символов, из которых состоит строка, определяет ее длину. Чтобы
получить это значение, достаточно вызвать следующий метод:
int length ()
В следующем фрагменте кода выводится символьная строка 11 3 11 ,
именно три символа содержит исходная строка s:
char chars[] ={'а' , 'Ь' , 'с' }; String s = new String(chars); System.out.println(s.length());
Специальные строковые операции
поскольку
Символьные строки являются очень важной составляющей программирова­
ния, и поэтому в Java обеспечивается специальная поддержка некоторых строко­ вых операций в рамках синтаксиса этого языка. Эти операции включают автома­ тическое создание новых экземпляров класса String из строковых литералов, сцепление многих объектов типа S t r i n g с помощью операции+, а также преобра­ зование других типов данных в их строковое представление. Для реализации всех

 Глава 17. Обработка символьных строк 533 этих операций имеются специальные явно указываемые методы, но для удобства
и большей ясности программирования на Java они выполняются автоматически.
Строковые литералы
В предыдущих примерах кода было показано, как создавать явным образом
объекты класса String из массива символов с помощью операции new. Но есть и более простой способ сделать то же самое с помощью строковых литералов. Для каждого строкового литерала в прикладной программе на Java автоматически соз­ дается объект типа St r ing. Таким образом, строковый литерал можно использо­ вать для инициализации объекта типа S t r i n g . Например, в следующем фрагменте кода создаются две одинаковые символьные строки:
charchars[] = { 'а', 'Ь', 'с' }; String sl new String(chars);
S t r i n g s 2 "аЬс"; //использовать
строковый
литерал
Объект типа String создается для каждого строкового литерала, и поэтому строковый литерал можно использовать в любом месте, где допускается приме­ нение объекта класса String. Например, методы этого класса можно вызывать непосредственно для символьных строк в кавычках как по ссылкам на объекты. Так, в приведенном ниже примере метод length () вызывается для символьной строки "аЬс ". Как и следовало ожидать, на экран выводится строка " 3 ".
System.out.println("abc".length());
Сцепление строк
Как правило, в Java не разрешается выполнять арифметические операции над объектами типа String. Но из этого правила имеется исключение: с помо­ щью операции +можно сцеплять, т.е. соединять две символьные строки, порож­ дая в итоге объект типа String. Операции сцепления символьных строк можно объединять в цепочку. Например, в приведенном ниже фрагменте кода выпол­ няется сцепление трех символьных строк. В итоге выводится символьная строка
"Ему 9 лет".
String age = "9";
String s ="Ему " + age + " лет."; System.out.println(s);
Сцепление символьных строк находит практическое применение, в частности
при создании очень длинных строк. Вместо того чтобы вводить длинные символь­
ные строки в исходном коде неразрывно и допускать их автоматический перенос
на новую строку, такие строки можно разбить на мелкие части, сцепляемые с по­
мощью операции+, как показано ниже.
//Использовать сцепление во избежание длинных строк
class ConCat {
puЫic static void main(String args[]) {

 534
Часть 11. Библиотека Java
String longStr = "Это может быть очень длинная "
+ "строка, которую следовало бы "
+ "перенести на новую строку. " + "Но благодаря сцеплению "
+ "этого удается избежать.";
System.out.println(longStr);
}
Сцепление символьных строк с другими типами данных
Символьные строки можно сцеплять с данными других типов. Рассмотрим в каче­
стве примера следующую немного измененную версию приведенного выше примера:
int age =9;
String s = "Ему " + age + " лет."; System.out.println(s);
В данном примере переменная age относится к типу int, а не String, но ре­ зультат получается прежним. Так происходит потому, что значение типа i n t авто­ матически преобразуется в свое строковое представление в объекте типа S t r i n g . После этого символьные строки сцепляются, как и прежде. Компилятор преоб­ разует операнд age в его строковый эквивалент, тогда как остальные операнды рассматриваемой здесь операции+ являются экземплярами класса String.
Сцепляя операнды других типов данных с символьными строками в операциях
сцепления, следует быть внимательным, иначе можно получить совершенно нео­
жиданные результаты. Рассмотрим в качестве примера следующий фрагмент кода:
Strings= "четыре: "+2+2; System.out.println(s);
В данном примере выводится следующий результат сцепления:
четыре:
2 2
вместо ожидаемого:
четыре: 4
Дело в том, что благодаря предшествованию операций сначала выполняется
сцепление символьной строки "четыре" со строковым представлением первого
числа 2, а полученный результат сцепляется затем со строковым представлением второго числа 2. Для того чтобы выполнить сначала целочисленное сложение, сле­ дует заключить эту операцию в круглые скобки, как показано ниже. В итоге строка
s будет содержать символы "четыре:
4 ".
String s = " четыре:
" + (2 + 2);
Преобразование символьных строк и метод t o S t r i n g ( )
При сцеплении символьных строк в Java данные других типов преобразуются в их строковое представление путем вызова одного из перегружаемых вариан-

 Глава 17. Обработка символьных строк 535
тов метода преобразования valueOf (),определенного в классе String. Метод v а l u е О f ( ) перегружается для всех примитивных типов данных, а также для типа Obj ect. В частности, для элементарных типов данных метод valueOf () возвра­ щает символьную строку, содержащую удобочитаемый эквивалент того значения, с которым он был вызван, а для объектов в методе valueOf () вызывается метод toString (). Подробнее о методе valueOf () речь пойдет далее в этой главе, а до тех пор рассмотрим метод t o S t r i n g () как удобное средство для строкового представления объектов создаваемых классов.
t o S t r i n g () реализуется в каждом классе, поскольку он
в классе Obj ect. Но реализация метода toString () по умолчанию редко оказы­ вается полезной. Поэтому во всех наиболее важных из создаваемых классов метод t o S t r i n g (),скорее всего, придется переопределить, чтобы обеспечить в каждом из них свое строковое представление. Правда, сделать это совсем не трудно, ис­ пользуя приведенную ниже общую форму метода toString (). Чтобы реализо­ вать этот метод в своем классе, достаточно возвратить объект типа String, со­ держащий удобочитаемую символьную строку, надлежащим образом описываю­ щую объект данного класса.
String toString()
Переопределение метода toString () в создаваемых классах позволяет пол­ ностью интегрировать их в среду программирования на Java. Например, переопре­ деленные варианты метода t o S t r i n g () можно применять в oпepaтopaxprint () и println (),а также в операциях сцепления символьных строк с данными дру­ гих типов. В следующей программе эта особенность демонстрируется на примере переопределения метода toString () в классе Вох:
11 Переопределить метод toString() в классе Вох class Вох {
douЫe width;
douЫe height;
douЫe depth;
Box(douЫe w, douЫe h, douЫe d) {
width =w; height = h; depth = d;
puЬlic String toString () {
return "Размеры " + width + " на "
+ depth + "на" + height + ".";
class toStringDemo {
puЬlic static void main(String args[J) {
Вох Ь = new Box(lO, 12, 14);
String s = "Объект Ь типа Вох: " + Ь;
11 выполнить сцепление символьной строки
11 с объектом типа Вох System.out.println(b);
11 преобразовать объект типа Вох в символьную 11 строку при выводе на консоль
Метод
определен

 536
Эта программа выводит следующий результат:
Размеры
1 4 . 0
на 12.О
Часть 11. Библиотека Java System.out.println(s);
}
1 0 . 0 на
Объект Вох типа Ь: Размеры 10.0 на 14.0 на 12.0
Извлечение символов
Класс String содержит немало способов извлечь символы из объекта типа String. Рассмотрим некоторые из них. И хотя символы, составляющие строку, нельзя индексировать таким же образом, как и в символьных массивах, тем не ме­ нее для выполнения операций во многих методах из класса String применяется индекс (или смещение) в символьной строке. Как и массивы, символьные строки индексируются, начиная с нуля.
Метод charAt {)
Чтобы извлечь из строки единственный символ, достаточно обратиться к нему
непосредственно, вызвав метод charAt ().Ниже приведена общая форма этого метода.
char charA t(int где)
Здесь параметр где обозначает индекс символа, который требуется получить.
Значение параметра где должно быть неотрицательным и указывать положение
извлекаемого
символа
в строке.
Метод
c h a r A t ( )
возвращает
символ, находя­
щийся в указанном положении. В следующем примере строковое значение "Ь"
присваивается переменной ch. char ch;
ch = "abc".charAt(l);
Метод getChars {)
Если требуется извлечь несколько символов сразу, то для этой цели можно вы­
звать метод getChars ().Ниже приведена общая форма этого метода. void getChars(int начало_источника, int конец_источника,
char target[], int начало_адресата)
Здесь параметр начало_источника обозначает индекс начала подстроки,
а параметр конец_источника - индекс символа, следующего после конца из­
влекаемой подстроки. Таким образом, извлекается подстрока, содержащая сим­
волы в пределах от начало_источника до конец_источника-1. Массив, при­
нимающий извлекаемые символы, задается как t a r g e t (т.е. адресат), а индекс, на­ чиная с которого извлекаемая подстрока будет копироваться в указанный массив
t a r g e t , - в
качестве
параметра
начало_адресата.
Следует,
однако, принять

 меры, чтобы
указанный
массив
t a r g e t
оказался
достаточного
размера
и
в нем
разместились все символы из заданной подстроки.
Глава 17. Обработка символьных строк
537
В следующем примере программы демонстрируется применение метода
getChars ( ):
class getCharsDemo {
puЬlic static void main(String args[J) {
String s = "Это демонстрация метода getChars() ."; int start = 4;
int end = 8;
char buf[J = new char[end - start]; s.getChars(start, end, buf, 0); System.out.println(buf);
Ниже приведен результат, выводимый данной программой.
демо
Метод getBytes ()
g e t
образование символов в байты, выбираемое на конкретной платформе по умолча­
нию. Ниже приведена простейшая форма этого метода.
byte[J getBytes()
Имеются и другие формы метода g e t B y t e s ( ) . Этот метод применяется, глав­ ным образом, в тех случаях, когда значения типа S t r i n g экспортируются в те сре­ ды, где не поддерживаются 16-разрядные символы в Юникоде. Например, в боль­ шинстве сетевых протоколов Интернета и форматов текстовых файлов применя­ ется 8-разрядный код ASCII для всех операций обмена текстовыми данными.
Метод toCharArray ()
Если требуется преобразовать все символы из объекта типа String в символь­ ный массив, то сделать это проще всего, вызвав метод t o C h a r A r r a y ().Этот метод возвращает массив символов из всей строки. Ниже приведена его общая форма.
char[] toCharArray()
Этот метод предоставляется в качестве дополнения, поскольку тот же самый
g e t C h a r s ()
B y t e s (),сохраняющий символы в массиве байтов. В этом методе выполняется пре­
В
качестве
альтернативы
методу
предоставляется
метод
результат можно получить, вызвав метод getChars ().
Сравнение символьных строк
В
классе
S t r i n g
имеется
немало
методов,
предназначенных для
сравнения
символьных строк или подстрок в них. Рассмотрим некоторые из этих методов.

 538 Часть 11. Библиотека Java
Методы equals () и equalsignoreCase ()
Для сравнения двух символьных строк на равенство достаточно вызвать метод
equals (),который имеет следующую общую форму: boolean equals(Object строка)
Здесь параметр строка обозначает объект типа String, который сравнива­ ется с вызывающим объектом типа String. Этот метод возвращает логическое значение true, если сравниваемые строки содержат те же самые символы и в том
логическое значение false. Сравнение выполняется с уче­ Для сравнения символьных строк без учета регистра букв достаточно вызвать
метод equalsignoreCase (). При сравнении двух символьных строк наборы символов А- Zи а- z в этом методе считаются одинаковыми. Он имеет следующую общую форму:
boolean equalsignoreCase(Object строка)
Здесь параметр строка обозначает объект типа String, который сравнива­ ется с вызывающим объектом типа String. Этот метод возвращает логическое
же порядке, а иначе -
том регистра букв.
значение
t r u e ,
если
сравниваемые
строки
содержат
же
самом
порядке,
а
иначе -
логическое
значение
Ниже приведен пример программы, где демонстрируется применение методов
equals () и equalsignoreCase ().
1 1
11 и equalsignoreCase() class equalsDemo {
e q u a l s ( )
Продемонстрировать
применение
методов
puЬlic static void main(String args[]) {
String sl String s2
"Привет";
"Привет";
S t r i n g
String s4 System.out.println(sl
+ System.out.println(sl
+ System.out.println(sl
+
System.out.println(sl +
+
sЗ
"Прощай";
"ПРИВЕТ";
Эта программа выводит следующий результат:
Привет равно Привет -> true Привет равно Прощай -> false Привет равно ПРИВЕТ -> false
Привет
равно
без учета
регистра
ПРИВЕТ
- > t r u e
+ " равно " + s2 + " -> sl.equals(s2));
+ " равно " + sЗ + " -> sl.equals(s3));
+ " равно " + s4 + " -> sl.equals(s4));
+ " равно без учета регистра " s4 + " -> " sl.equalsignoreCase(s4));
одинаковые
f a l s e .
символы
в том

 Глава 17. Обработка символьных строк 539 Метод regionмatches ()
Этот метод сравнивает одну заданную часть символьной строки с другой ее ча­
стью. Имеется также перегружаемая форма метода regionMatches () для срав­ нения частей символьной строки без учета регистра. Ниже приведены обе общие формы этого метода.
boolean regionMatches(int int int
начальный_индекс, String строка , 2
индекс_начала_строки ,
2
количество_символов)
boolean regionMatches(boolean игнорировать_регистр_букв,
int начальный_индекс,
int индекс_начала_строки,, int количество_символов) -
В обеих формах данного метода параметр начальный_индекс обознача­
ет индекс начала той части символьной строки из вызывающего объекта типа
String, с которой сравнивается символьная строка, задаваемая в качестве пара­ метра строка • Индекс символа, начиная с которого должна сравниваться задан­
2
ная строка , задается в качестве параметра индекс_начала_строки , а длина
22
сравниваемой подстроки - в качестве параметра количество_символов. Если
во второй форме данного метода параметр игнорировать_регистр_букв при­
нимает логическое значение t rue, то сравнение подстрок выполняется без учета регистра букв. В противном случае регистр букв учитывается.
Методы startsWith () и endsWith ()
В классе String определены два метода, являющиеся в большей или меньшей степени специализированными формами метода regionMatches (). Так, в ме­ тоде startWith () определяется, начинается ли заданный объект типа String
e n d s W i t h () -
типа String заданной подстрокой. Ниже приведены общие формы этих методов.
с
указанной
boolean startsW ith(String boolean endsW ith(String строка)
Здесь параметр строка обозначает подстроку, наличие которой проверяется
в начале или в конце вызывающего объекта типа St r ing соответственно. Если эта подстрока присутствует в данном месте вызывающего объекта типа String, то
возвращается
логическое
значение
t r u e ,
а
иначе -
логическое
значение
f a l s e .
и
символьной
строки, а
в
Например, в результате следующих вызовов:
"Foobar". endsWi th ( "bar")
"Foobar".startsW ith("Foo") возвращается логическое значение true.
методе
строка)
завершается ли
объект
S t r i n g
строка
,
2

 540 Часть 11. Библиотека Java
Во второй, приведенной ниже форме метода s t a r t s W i t h () можно задать на­ чальную точку для поиска заданной подстроки.
boolean startsW ith(String строка, int
Здесь начальный_индекс обозначает индекс символа, с которого начинается
поиск заданной подстроки в исходной строке. Например, в результате следующего
вызова:
"Foobar".startsW ith("bar", 3) возвращается логическое значение true.
Метод equal s ( ) в сравнении с операцией
Следует иметь в виду, что метод equals () и операция== выполняют раз­ ные действия. Как пояснялось ранее, метод equal s () сравнивает символы из
объекта типа String, тогда как операция== -
деляет, ссылаются ли они на один и тот же экземпляр. В следующем примере
программы
показано,
что два
разных
объекта типа
S t r i n g
могут
содержать
одинаковые символы, но ссылки на эти объекты оказываются при сравнении
неравнозначными:
11 Метод equals() в сравнении с операцией class EqualsNotEqualTo {
puЬlic static void main(String args[]) {
String sl
String s2 = new String(sl);
System.out.println(sl + " равно " + s2 + " -> " + sl.equals(s2)); System.out.println(sl + " == " + s2 + " -> " + (sl == s2));
Переменная
s l
ссылается
на экземпляр
класса
S t r i n g ,
созданный
присваи­
"Привет";
ванием ей строкового литерала "Привет". А объект, на который ссылается пере­
менная s2, создается с использованием переменной sl в качестве инициализато­ ра. Таким образом, содержимое обоих объектов типа String одинаково, но это разные объекты. Следовательно, переменные s l и s 2 ссылаются не на один и тот же объект, и поэтому они не равны (при сравнении в операции==), как доказывает приведенный ниже результат, выводимый данной программой.
Привет равно Привет -> true Привет == Привет -> false
Метод compareтo ( )
Зачастую недостаточно знать, что символьные строки одинаковы. В приклад­
ных программах, выполняющих сортировку, обычно требуется выяснить, оказыва­
ется ли текущая символьная строка меньше, больше или равной следующей строке.
начальный_индекс)
две ссылки на объекты и опре­

 Глава 17. Обработка символьных строк 541 Одна символьная строка меньше другой, если она следует перед ней в лексикогра­
фическом порядке, и больше другой, если она следует после нее. Для этой цели
служит метод compareTo (),определенный в интерфейсе ComparaЬle<T>, реа­ лизуемом в классе String. Этот метод имеет следующую общую форму:
int compareTo(String строка)
Здесь параметр строка обозначает объект типа String, сравниваемый с вы­ зывающим объектом типа String. Возвращаемый результат сравнения символь­ ных строк интерпретируется так, как показано в табл. 17.1.
Таблица17.1. РезультатсравнениясимвольныхстрокметодомcompareTo ( ) Значение
 Меньше нуля
Больше нуля
Нуль
Описание
Вызывающая символьная строка меньше заданной с'1!рохи
Вызывающая символьная строка больше заданной С'!!рохи
Символьные строки равны
В приведенном ниже примере программы сортируется массив символьных
строк. Для определения порядка пузырьковой сортировки в этой программе ис­
пользуется метод compareTo ().
11 Пузырьковая
class SortString {
типа S t r i n g
сортировка
объектов
static String arr [] = {
1'Now", "is11 , 11 the", 1'time11 , 11 for11 , "all11 , 1'good1', "rnen11 , 11 to11 , 11 come11 , "to", "the", 11 aid11 / 11 Qf11 I 11 their11 1 "country"
};
puЬlic static void main(String args[])
for(int j =О; j < arr.length; j++) { for(int i = j + 1; i < arr.length; i++)
if(arr[i] .compareTo(arr[j]) < 0) { String t = arr[j];
arr[j] arr[i] ;
arr [i] t;
System.out.println(arr[j]);
Эта программа выводит отдельные слова, отсортированные в следующем по­
рядке:
Now
aid
all
соте country for good
is

 542 Часть 11. Библиотека Java
men of the the their time to
to
ныхстрок в методе c o m p a r e T o ( ) происходит с учетом регистра. В частности, слово
11 Now 11
буквы, а прописная буква имеет меньшее значение в наборе символов в коде ASCII.
Если символьные строки требуется сравнивать без учета регистра, то для этой
цели служит метод compareToignoreCase ().Ниже приведена его общая форма. int compareToignoreCase(String строка)
Этот метод возвращает такой же результат, как и метод compareTo ( ), но толь­ ко без учета регистра символов. Попробуйте ввести этот метод в приведенный
Как следует из результата выполнения данной программы, сравнение символь­
следует прежде всех остальных слов, поскольку оно начинается с прописной
выше пример программы. В итоге слово 11 Now 11 отсортированных слов.
Поиск в символьных строках
уже не появится первым в списке
В классе String предоставляются два метода для поиска в символьной строке определенного символа или подстроки.
Оба эти метода перегружаются несколькими способами и по-разному. Но в лю­
бом случае они возвращают позицию в строке (индекс), где найден символ или
подстрока,
а при
неудачном
исходе
поиска -
значение
- 1 .
i n d e x O f () -
• Метод
• Метод lastindexOf () - находит последнее вхождение символа или под­
строки.
находит
первое
вхождение
символа или
подстроки.
Для поиска первого вхождения символа в строке служит следующая форма ме­
тода indexOf ():
int indexOf(char символ)
А для поиска последнего вхождения символа в строке служит такая форма ме­
тода lastindexOf ():
int lastindexOf(char символ)
Здесь параметр символ обозначает искомый символ в строке.
И наконец, для поиска первого или последнего вхождения подстроки служат
приведенные ниже формы методов indexOf () и lastindexOf (),где параметр строка обозначает искомую подстроку.
int indexOf(String строка)
int lastindexOf(String строка)

 Глава 17. Обработка символьных строк 543 Воспользовавшись следующими формами рассматриваемых здесь методов,
можно указать начальную позицию для поиска символа или подстроки в исходной
строке:
i n t i n d e x O f ( i n t символ, i n t
int lastindexOf(int символ, int начальный_индекс)
int indexOf(String строка, int начальный_индекс)
int lastindexOf(String строка, int начальный_индекс)
Здесь параметр начальный_индекс задает начальную позицию для поис­
начальный_индекс)
i n d e x O f ( )
начальный_индекс и до конца строки, а в методе lastindexOf () - от пози­
ции начальный_индекс и до нуля.
В следующем примере программы демонстрируется применение различных
форм рассматриваемых здесь методов индексирования для поиска символов
и подстрок в исходной строке:
11 Продемонстрировать применение разных форм 11 методов indexOf() и lastindexOf()
class indexOfDemo {
puЬlic static void main(String args[])
String s = "Now is the time for all good men •
+ •to come to the aid of their country.•; System.out.println(s);
System.out.println("indexOf(t) = • + s.indexOf( 't')); System.out.println("lastindexOf(t) = •
+ s.lastindexOf('t') ); System.out.println("indexOf(the) = "
+ s.indexOf("the")); System.out.println("lastindexOf(the) = •
+ s.lastindexOf("the")); System.out.println("indexOf(t, 10) = •
+ s.indexOf('t', 10)); System.out.println("lastindexOf (t, 60) = "
+ s.lastindexOf( 't', 60)); System.out.println("indexOf(the, 10) = "
+ s.indexOf("the", 10)); System.out.println("lastindexOf(the, 60) = "
+ s.lastindexOf("the", 60));
Ниже приведен результат, выводимый данной программой.
Now is the time for all good men to come to the aid of their country.
indexOf(t) = 7
lastindexOf(t) = 65
indexOf(the) = 7 lastindexOf(the) = 55 indexOf(t, 10) = 11 lastindexOf(t, 60) = 55 indexOf(the, 10) = 44 lastindexOf(the, 60) = 55
ка
в
символьной
строке. В
методе
поиск
начинается
от позиции

 544 Часть 11. Библиотека Java Видоизменение символьных строк
Объекты типа String неизменяемы, и поэтому всякий раз, когда требуется их видоизменить, их содержимое следует скопировать в объект типа S t r i n g B u f f e r или S t r i n g B u i l d e r или же воспользоваться одним из методов из класса S t r i n g 1 создающих новые копии символьных строк с внесенными изменениями. В этом разделе рассматриваются простейшие из этих методов.
Метод substring {)
Чтобы извлечь подстроку из символьной строки, достаточно вызвать метод
s u b s t r i n g () 1
String substring(int начальный_индекс)
Здесь параметр на чальный_индекс обозначает позицию, с которой должна
начинаться подстрока. Эта форма возвращает копию подстроки, которая начина­
ется с позиции начальный_индекс и продолжается до завершения вызывающей
строки.
у которого имеются две формы. Первая его форма такова:
s u b s t r i n g () позволяет указать как начальный, так и конечный индекс подстроки следующим образом:
String substring(int начальный_индекс, int конечный_индекс)
Здесь параметр на чальный_индекс обозначает позицию, с которой должна
начинаться извлекаемая подстрока. а параметр конечный_индекс - позицию,
на которой должна оканчиваться извлекаемая подстрока. Возвращаемая под­
строка содержит все символы, от первой позиции и до последней, но исключая
последнюю.
В следующем примере программы метод substring () используется для за­ мены в исходной символьной строке всех вхождений одной подстроки другой под­ строкой.
Вторая
форма
метода
/ /
class StringReplace
puЬlic static void main(String args[]) {
String org = "This is а test. This is, too."; String search = "is";
String sub = "was";
String result = "";
int i;
Замена
подстроки
d o
{ / / System.out.println(org); i = org.indexOf(search); if(i != -1) {
заменить все
совпадающие
подстроки
result org.substring(O, i); result result + sub;
result result + org.substring(
i + search.length()); org result;

 } while(i != -1);
Глава 17. Обработка символьных строк 545
Ниже приведен результат, выводимый данной программой.
This is а test. This is, too. Thwas is а test. This is, too. Thwas was а test. This is, too. Thwas was а test. Thwas is, too. Thwas was а test. Thwas was, too.
Метод concat ( )
Чтобы соединить две подстроки, достаточно вызвать метод concat ().Ниже
приведена его общая форма:
String concat(String строка)
Этот метод создает новый строковый объект, содержащий вызываемую строку,
в конце которой добавляется содержимое параметра строка. Метод concat () выполняет то же действие, что и операция +, т.е. сцепление символьных строк.
Например,
в
следующем
фрагменте
кода соединенная
строка
11 o n e t w o 11 присваи­
вается переменной s2: String sl = "one";
String s2 = sl.concat("two");
Этот фрагмент кода дает такой же результат, как и приведенный ниже фрагмент
кода.
String sl "one"; String s2 sl + 11 two11 ;
Метод replace ()
У этого метода имеются две формы. В первой форме все вхождения одного сим­
вола в исходной строке заменяются другим символом:
String replace(char исходный, char заменяемый)
Здесь параметр исходный обозначает заменяемый символ, а параметр
заменяемый -
заменяющий. В результате замены возвращается видоизмененная
символьная строка. Например, в следующей строке кода:
String s = "Hello" .replace( 'l', 'w');
переменной s присваивается символьная строка 11 Hewwo 11 ,
тате замены символа ' l ' на ' w ' в исходной строке. А во второй форме метода
r e p l a c e () одна
образом:
String replace(CharSequence исходная, CharSequence заменяемая)
последовательность
символов
заменяется
другой
следующим
получившаяся в резуль­

 546 Часть 11. Библиотека Java Метод trim()
Этот метод возвращает копию вызывающей символьной строки, из которой
удалены все начальные и конечные пробелы. Он имеет следующую общую форму:
String trim ()
Ниже приведен
пример
применения
метода
t r i m ( ) . В итоге переменной s мир".
присваивается символьная строка "Здравствуй,
String s = " Здравствуй, мир
".trim();
Метод trim () очень удобно вызывать для обработки команд, вводимых пользо­ вателем. Так, в приведенном ниже примере программы пользователю сначала пред­ лагается ввести название штата, а затем выводится название города - столицы штата. Метод trim () используется в этой программе для удаления всех начальных и конеч­ ных пробелов, которые могут быть непреднамеренно введены пользователем.
//Использовать
метод
обработки
команд,
/ /
import java.io.*; class UseTrim {
вводимых
t r i m ( ) для пользователем
puЬlic static void main(String args[J) throws IOException {
/ /
//типа BufferedReader, используя стандатный
/! поток ввода System.in
Buf feredReader br = new
BufferedReader(new InputStreamReader(System.in)); String str;
System.out.println("Bвeдитe 'стоп' для завершения.");
создать
System.out.println("Bвeдитe
буферизованный
поток
название
do {
str = br.readLine();
str = str.trim (); //удалить пробелы i f (str. equals ("Иллинойс"))
System.out.println("Cтoлицa - Спрингфилд.");
else if (str. equals ("Миссури")) System.out.println("Cтoлицa - Джефферсон-сити.");
e l s e
System.out.println("Cтoлицa - Сакраменто.");
e l s e
if(str.equals("Kaлифopния"))
if(str.equals("Baшингтoн"))
System.out.println("Cтoлицa - Олимпия.");
11 ".
while(!str.equals("cтoп"));
Преобразование данных методом valueOf () Метод valueOf () преобразует данные из внутреннего представления в удо­
S t r i n g для всех встроенных в Java типов данных таким образом, чтобы каждый тип был
бочитаемую
форму. Этот
статический
метод
перегружается
в
классе
чтения
данных
штата:
" ) ;

 i n t
количество_символов)
Глава 17. Обработка символьных строк 547
правильно преобразован в символьную строку. Метод valueOf () перегружается и для типа Obj ect, поэтому объект типа любого создаваемого класса также мо­ жет использоваться в качестве аргумента. (Напомним, что класс Obj ect является суперклассом для всех остальных классов.) Ниже приведены некоторые формы метода valueOf ().
static String valueOf(douЫe число) static String valueOf(long число) static String valueOf(Object объект) static String valueOf(char chars[])
Как упоминалось ранее, метод valueOf () вызывается в том случае, если тре­ буется получить строковое представление некоторого другого типа данных, на­ пример в операциях сцепления символьных строк. Этот метод можно вызывать и непосредственно с любым типом данных, чтобы получить подходящее строковое представление этого типа данных. Все примитивные типы данных преобразуются в их общее строковое представление. Для любого объекта, передаваемого методу valueOf (),возвращается результат вызова метода toString ().На самом деле того же самого результата можно добиться, просто вызвав метод toString ().
Для большинства массивов метод valueOf () возвращает зашифрованную символьную строку, которая обозначает, что это массив определенного типа. Но для массивов типа char создается объект типа String, содержащий все символы из массива типа char. Для этой цели служит следующая форма метода valueOf ():
static String valueOf(char символы[], int начальный_индекс,
Здесь chars обозначает массив, содержащий символы, параметр начальный_ индекс - позицию в массиве, с которой начинается подстрока, а параметр количество_ символов - длину подстроки.
Смена регистра букв в строке
Метод t o L o w e r C a s e ( ) преобразует все символы строки из верхнего регистра букв в нижний, а метод toUpperCase () - из нижнего регистра букв в верхний. Небуквенные символы, например десятичные цифры, остаются без изменения. Ниже приведены простейшие формы этих методов.
String toLowerCase() String toUpperCase()
Оба метода возвращают объект типа S t r i n g , содержащий эквивалент вызываю­ щей строки в нижнем или верхнем регистре символов соответственно. В обоих слу­ чаях преобразование выполняется с учетом региональных настроек по умолчанию.
Ниже приведен пример программы, демонстрирующий применение методов
toLowerCase () и toUpperCase ().
11 Продемонстрировать 11 и toLowerCase() class ChangeCase {
применение
методов
t o U p p e r C a s e ( )

 548 Часть 11. Библиотека Java
puЬlic static void main(String args[])
(
S t r i n g s = "Это System.out.println("Иcxoднaя String upper = s.toUpperCase(); String lower = s.toLowerCase();
тест.";
System.out.println("Bepxний
System.out.println("Hижний
строка:
регистр
регистр
" +
s ) ;
Эта программа выводит следующий результат:
Исходная строка: Это тест
Верхний регистр букв: ЭТО ТЕСТ
Нижний регистр букв: это тест
Следует также иметь в виду, что существуют и перегружаемые варианты мето­
дов toLowerCase () и toUpperCase (),позволяющие определять объект типа Locale для управления преобразованием. В некоторых случаях определение ре­ гиональных настроек может иметь особое значение и способствовать интернаци­ онализации прикладной программы.
Соединение символьных строк
Начиная с версии JDK 8, в классе String содержится метод j oin (), предна­ значенный для соединения двух и более символьных строк, разграничиваемых указанным разделителем, например пробелом или запятой. У этого метода есть две общие формы. Ниже приведена первая из них.
static String join(CharSequence разделитель, CharSequence . . . строки)
Здесь параметр разделитель обозначает знак, употребляемый для разделе­
ния последовательностей символов, задаваемых в качестве параметра строки.
Благодаря тому что в классе String реализуется интерфейс CharSequence, в качестве параметра строки может быть указан список символьных строк. (Подробнее об интерфейсе CharSequence речь пойдет в главе 18.) В следующем примере программы демонстрируется применение первой формы метода j oin ():
11 Продемонстрировать
применение
метода
j o i n ( ) ,
S t r i n g
puЬlic static void main(String args[]) (
11 определенного
class StringJoinDemo (
в
классе
String result = String.join(" ", "Alpha",
11 Beta'1 , "Garruna");
System.out.println(result);
result = String.join(", ", "John", "ID#: 569", "E-mail: John@HerbSchildt.com");
System.out.println(result);
букв: " букв: "
+
u p p e r ) ; l o w e r ) ;
+

 Глава 17. Обработка символьных строк 549 Эта программа выводит следующий результат:
Alpha Beta Gamma
John, ID#: 569, E-mail: John@HerbSchildt.com
При первом вызове метода j oin () вводится пробел между каждой из символь­
ных строк, а при втором его вызове -
запятая с пробелом. Данный пример наглядно
показывает, что разделитель совсем не обязательно должен быть одиночным знаком.
Вторая форма метода j oin () позволяет соединить список символьных строк, получаемых из объекта класса, реализующего интерфейс IteraЫe. Среди про­ чего, интерфейс IteraЫe реализуется в классах из каркаса коллекций Collections Framework, рассматриваемого в главе 19. Подробнее об интерфейсе IteraЫe речь пойдет в главе 18.
Дополнительные методы из класса String
Помимо представленных выше методов, в классе S t r i n g имеется также целый
ряд других методов, включая и перечисленные в табл. 17.2. Таблица 17.2. Дополнительные методы из класса S t r i n g
 Метод
int codePointAt(int i)
int codePointBefore(int i)
int codePointCount
жонец)
( C h a r S e q u e n c e
boolean contentEquals
( C h a r S e q u e n c e
boolean contentEquals
Описание
Возвращает кодовую точку в Юникоде на позиции i Возвращает кодовую точку в Юникоде на позиции,
предшествующей i
Возвращает количество кодовых точек в части
начало, i n t
( i n t
boolean contains
вызывающей
символьной
строки
от позиции
(StringBuffer static String
фopнa'l'RlpYDЦl!Jl
вызывающий объект содержит указанную
O b j e c t . . . арrунвнtп1)
заданная форма'l'ирупца.ll С'l'рожа. (Подробнее
С!J:'РОЖа)
С!J:'РОЖа)
С!J:'РОЖа)
format(String
с'l'рожа,
вызывающий объект содержит указанную
static String format(Locale Возвращает символьную строку,
регион, String фopнa'l'RlpYJCllЦl!Jl С'l'рОЖа, O b j e c t . . . арrунвнtп1)
boolean isEmpty()
отформатированную так, как определяет
заданная форма'l'ир;уzщая С'l'рожа. (Подробнее
начало и до позиции жонвц-1
t r u e , если вызывающий объект содержит указанную
Возвращает
логическое
значение
С!J:'РОЖу,
а
иначе -
логическое
значение
f a l s e
если
Возвращает
логическое
значение
t r u e ,
С'l'рожу,
а
иначе -
логическое
значение
f a l s e
если
Возвращает
логическое
значение
t r u e ,
с'l'рожу,
а
иначе -
логическое
значение
f a l s e
Возвращает символьную строку,
отформатированную так, как определяет
о форматировании -
в rлаВе 20.)
о форматировании -
в глаВе 20.)
Возвращает логическое значение true, если вызывающая строка не содержит символы и имеет нулевую длину

 550
Часть 11. Библиотека Java
выражение,
С!l'рОЖа)
String новая
matches(string
Возвращает логическое значение true, если вызывающая строка совпадает с заданным регулярным выражением, а иначе - логическое значение false
Возвращает индекс позиции в вызывающей
строке, которая отстоит на заданное число
кодовых точек от начальной позиции, задаваемой
по индексу начало
Возвращает символьную строку, в которой
первая подстрока, совпадающая с заданным
регулярным_выражением, заменяется новой_
С!I'рОЖОЙ
Возвращает символьную строку, в которой
все подстроки, совпадающие с заданным
регулярным_выражением, заменяются новой_
С!I'рОЖОЙ
Разбивает вызывающую строку на части
и возвращает массив, содержащий результат.
Каждая часть разделяется заданным
регулярным_выражением
Разбивает вызывающую строку на части
и возвращает массив, содержащий результат.
Каждаячастьразделяетсязаданнымрегулярным
выражением. Количество частей определяется - параметром мажсим;ун. Если параметр нажсимум принимает отрицательное значение, вызывающая строка разбивается полностью. Если же параметр мажсинум принимает неотрицательное значение,
то последний элемент возвращаемого массива
содержит остаток вызывающей строки. А если
значение параметра мажсимун равно нулю, то
и в этом случае вызывающая строка разбивается
полностью
Возвращает подстроку из вызывающей строки,
регулярное_выражение)
int offsetByCodePoints (int начало, int число)
String replaceFirst (String регулярное
String replaceAll (String регулярное
выражение,
C!l'J'OЖ:a)
String[]
String новая split(String
-
Окончание табл. 17.2
 Метод
Ьoolean
Описание
регулярное_выражение)
String[] split(String
регулярное
выражение,
int мажсимум)
CharSequence subSequence
( i n t i n t
начальный
индежс,
жонечный_и'Ндежс)
позицией жонечныii
индежс и кончая
индежс. Этот метод
начиная с позиции начальный
требуетсядля интер<fейсаCharSequence, реализуемого в классе String
Обратите внимание на то, что некоторые из перечисленных выше методов опе­
рируют регулярными выражениями, которые рассматриваются в главе 30.
Класс StringBuffer
Этот класс подобен классу S t r i n g , в котором предоставляется большая часть функциональных возможностей для обработки символьных строк. Как вам долж­ но быть уже известно, класс String представляет неизменяемые последователь­
ности
символов
постоянной
длины, тогда
как класс
S t r i n g B u f f e r - расширя-

 Глава 17. Обработка символьных строк 551 емые и доступные для изменений последовательности символов. Он позволяет
вставлять символы и подстроки в середину исходной строки или добавлять их в ее
конце. Объект типа StringBuffer автоматически наращивается, чтобы предо­ ставить место для подобных расширений, и зачастую для возможности такого наращивания он содержит больше предварительно определенных символов, чем требуется на самом деле.
В классе StringBuffer определены следующие четыре конструктора:
StringBuffer ()
StringBuffer(int размер) StringBuffer(String строка) StringBuffer(CharSequence символы)
Первый конструктор по умолчанию (т.е. без параметров) резервирует место
для 16 символов, не перераспределяя память. Второй конструктор принимает це­ лочисленный аргумент, явно задающий размер буфера. Третий конструктор при­ нимает аргумент типа String, задающий начальное содержимое объекта типа
S t r i n g B u f f e r
для 16
память. Класс S t r i n g B u f f e r выделяет место для 16 дополнительных символов,
нительных
и
резервирующий
класс
место
если не указывается конкретный размер буфера, чтобы сэкономить время, затра­
чиваемое на перераспределение памяти. Кроме того, частое перераспределение
памяти может привести к ее фрагментации. Выделяя место под несколько допол­
символов,
S t r i n g B u f f e r
повторных перераспределений памяти. Четвертый конструктор создает объект,
содержащий последовательность символов, задаваемых в качестве параметра
символы, а также резервирует место для 16 дополнительных символов.
Методы length () и capacity ()
Текущую длину объекта типа StringBuffer можно получить, вызвав метод length (),а текущий объем выделенной памяти - вызвав метод capacity (). Эти методы имеют следующие общие формы:
int length() int capacity()
В приведенном ниже примере программы демонстрируется применение мето­
дов length () и capacity ().
11 Сравнить методы length() и capacity() 11 из класса StringBuffer
class StringBuf f erDemo {
puЫic static void main(String args[]) { StringBuffer sb = new StringBuffer("Hello");
= " + s b ) ; System.out.println("длинa = " + sb.length() );
System.out.println("бyфep
System.out.println("eмкocть
• + sb.capacity());
снижает
символов,
количество
не перераспределяя
требующихся

 552 Часть 11. Библиотека Java
Ниже приведен результат, выводимый данной программой. Он показывает, ка­
ким образом класс StringBuffer резервирует свободное пространство для до­ полнительного манипулирования символьными строками.
буфер = Hello длина = 5 емкость = 21
s b
" H e l l o "
дании, поэтому длина буфера для хранения этого значения равна 5. А объем вы­ деляемой памяти (емкость буфера) составляет 21, поскольку 16 дополнительных
Переменная
символов добавляются автоматически.
инициализируется
строковым
Метод ensureCapacity ()
Если требуется предварительно выделить место для определенного количества
символов после создания объекта типа S t r i n g B u f f e r , то можно воспользовать­ ся методом ensureCapacity (),чтобы установить емкость буфера. Это удобно, если заранее известно, что к объекту типа S t r i n g B u f f e r предполагается присо­ единить большое количество мелких символьных строк. Метод ensureCapac- i t y ( ) имеет следующую общую форму:
void ensureCapacity(int минимальная_емкость)
Здесь параметр минимальная_ емкость обозначает минимальный размер бу­
фера. (Буферы, размер которых превышает заданную минимапьную_емкость,
также могут быть выделены из соображений эффективности.)
Метод setLength ()
Для задания длины символьной строки в объекте типа StringBuffer служит
метод s e t L e n g t h (),общая форма которого выглядит следующим образом: void setLength(int длина)
Здесь параметр длина обозначает конкретную длину символьной строки. Ее
значение должно быть неотрицательным.
Когда увеличивается длина символьной строки, в конце существующей строки
добавляются пустые символы. Если метод setLength () вызывается со значени­
ем меньше
текущего
значения,
возвращаемого
оказавшиеся за пределами вновь заданной длины строки, будут удалены. В приме­
ре программы,
в
представленном
меняется для сокращения объекта типа StringBuffer.
Методы charAt ( ) и setCharAt ( )
следующем
s e t L e n g t h ( ) при­
Значение отдельного символа можно извлечь из объекта типа S t r i n g B u f f e r , вызвавметод charAt ().АзначениесимволавобъектетипаStringBuffer мож-
значением
методом
l e n g t h
(),то символы,
разделе,
метод
при ее соз­

 Глава 17. Обработка символьных строк 553 но установить с помощью метода setCharAt ().Ниже приведены общие формы
этих методов.
char charA t(int где)
void setCharAt(int где, char символ)
В форме метода c h a r A t ( ) параметр где обозначает индекс извлекаемого сим­ вола, а в форме метода setCharAt () - индекс задаваемого символа, тогда как
параметр символ -
значение этого символа. Значение параметра где для обоих
методов должно быть неотрицательным и не должно указывать место за предела­
ми символьной строки.
В следующем примере программы демонстрируется применение методов
charAt () и setCharAt ():
11 Продемонстрировать 11 и setCharAt()
class setCharAtDemo {
применение
методов
c h a r A t ( )
puЫic static void main(String args(]) { StringBuffer sb = new StringBuffer("Hello");
до = • + s b ) ; System.out.println("дo вызова charAt(l) = " + sb.charAt(l));
sb.setCharAt(1, 'i');
sb.setLength(2);
System.out.println("бyфep
System.out.println("пocлe вызова charAt(l) "+ sb.charAt(l));
Эта программа выводит следующий результат:
System.out.println("бyфep
буфер до = Hello
до вызова
charA t(l) = = H i
е
= i
буфер
после
после
вызова
charA t(l)
после
= • + s b ) ;
Метод getChars ()
Для копирования подстроки из объекта типа StringBuffer в массив служит
метод getChars (),имеющий следующую общую форму:
void getChars(int начало_источника, int конец_источника, char target[], int начало_адресата)
Здесь
параметр
на чало_источника
обозначает
индекс
начала
подстроки,
а параметр конец_источника - индекс символа, следующего после конца тре­
буемой подстроки. Это означает, что подстрока содержит символы от позиции
начало_источника до позиции конец__источника-1. Массив, принимающий
символы, передается в качестве параметра t a r g e t (т.е. адресат), а индекс массива,
куда копируется подстрока, -
в качестве параметра начало_адресата. Следует
принять меры к тому, чтобы массив t a r g e t имел достаточный размер, позволяю­ щий вместить количество символов из указанной подстроки.

 554 Часть 11. Библиотека Java Метод append ( )
Метод a p p e n d ( ) присоединяет строковое представление любого другого типа данных в конце вызывающего объекта типа StringBuffer. У него имеется не­ сколько перегружаемых вариантов. Ниже приведены некоторые из них.
StringBuffer append(String строка) StringBuffer append(int число) StringBuffer append(Object объект)
Строковое представление каждого параметра зачастую получается в результате
вызова метода S t r i n g . v a l u e O f ().Полученный результат присоединяется к те­ кущему объекту типа StringBuffer. Сам буфер возвращается каждым вариан­ том метода a p p e n d ( ) . Это позволяет соединить в цепочку несколько последова­ тельных вызовов, как показано в следующем примере программы:
11 Продемонстрировать class appendDemo {
применение
метода
a p p e n d ( )
puЬlic static void main(String args[J) { String s;
intа =42;
StringBuffer sb = new StringBuffer(40);
s = sb.append("a = ") .append(a) .append("!") .toString(); System.out.println(s);
Ниже приведен результат, выводимый данной программой.
а = 42!
Метод insert ()
Этот метод вставляет одну символьную строку в другую. Он перегружается та­
ким образом, чтобы принимать в качестве параметра значения всех примитивных
типов плюс объекты типа String, Object и CharSequence. Подобно методу append (), метод insert () получает строковое представление значения, с ко­ торым он вызывается. Эта строка затем вставляется в вызывающий объект типа StringBuffer. Ниже приведены некоторые общие формы метода insert ().
StringBuffer insert(int индекс, String строка) StringBuffer insert(int индекс, char символ) StringBuffer insert(int индекс, Object объект)
Здесь параметр индекс обозначает индекс позиции, на которой символьная
строка будет вставлена в вызывающий объект типа StringBuffer. В следующем примере программы демонстрируется вставка слова "нравится" между словами
"Мне" и
"Java ":
11 Продемонстрировать class insertDemo {
применение
метода
i n s e r t ( )

 puЬlic static void main(String args[]) { StringBuffer sb = new StringBuffer("Mнe Java!");
sb. insert (4,
"нравится "); System.out.println(sb);
Эта программа выводит следующий результат:
Мне нравится Java!
Метод reverse ( )
Глава 17. Обработка символьных строк 555
Изменить порядок следования символов в объекте типа S t r i n g B u f f e r на об­ ратный можно с помощью метода reverse (),общая форма которого приведена ниже.
StringBuffer reverse()
Этот метод возвращает объект с обратным порядком следования символов
по сравнению с вызывающим объектом. В следующем примере программы демон­
стрируется применение метода reverse ():
11 Изменить порядок следования символов в объекте 11 типа StringBuffer с помощью метода reverse() class ReverseDemo {
puЬlic static void main(String args[]) { StringBuffer s = new StringBuffer("abcdef");
System.out.println(s); s.reverse(); System.out.println(s);
Ниже приведен результат, выводимый данной программой.
abcdef fedcba
Методы delete () и deleteCharAt ()
Удалить символы из объекта типа StringBuffer можно с помощью методов
delete () и deleteCharAt ().Ниже приведены их общие формы.
StringBuffer delete(int начальный_индекс, int конечный_индекс) StringBuffer deleteCharAt(int позиция)
Метод
d e l e t e ( )
удаляет
последовательность
объекта. Его параметр начальный_индекс обозначает индекс первого символа,
который требуется удалить, а параметр конечный_индекс - индекс симво­
ла, следующего за последним из удаляемых символов. Таким образом, удаляемая
подстрока начинается с позиции на чальный_индекс и оканчивается на позиции
символов
из вызывающего

 556 Часть 11. Библиотека Java
конечный_индекс-1. Из этого метода возвращается результирующий объект
типа StringBuffer.
Метод deleteCharAt () удаляет символ на указанной позиции. Из этого ме­
тода возвращается результирующий объект типа S t r i n g B u f f e r .
В следующем примере программы демонстрируется применение методов
delete () и deleteCharAt ():
11 Продемонстрировать 11 и deleteCharAt() class deleteDemo (
методов
d e l e t e ( )
puЬlic static void main(String args[J) (
StringBuffer sb = new sb.delete(З, 1 1 ) ;
простой тест.");
метод
StringBuffer replace(int начальный_индекс,
применение
System.out.println("Пocлe вызова метода
delete(): " + sЬ);
sb.deleteCharA t(O);
System.out.println("Пocлe вызова метода
deleteCharAt(): • + sb);
Эта программа выводит следующий результат:
После вызова метода delete(): Это тест.
После вызова метода deleteCharAt(): то тест.
Метод replace ()
StringBuffer("Этo
r e p l a c e ( ) , можно заменить
в объекте типа StringBuf fer. Ниже приведена общая форма этого метода.
Вызвав
i n t
String строка)
конечный_индекс,
Подстрока, которую требуется заменить, задается параметрами начальный_
индекс и конечный_индекс. Таким образом, заменяется подстрока от символа
на позиции начальный_индекс до символа на позиции конечный_индекс-1.
А заменяющая строка передается в качестве параметра строка. Из этого метода
возвращается результирующий объект типа S t r i n g Bu f f еr .
В следующем примере программы демонстрируется применение метода
replace ():
r e p l a c e ( ) puЬlic static void main(String args[J) (
11 Продемонстрировать class replaceDemo (
метода
}
S t r i n g B u f f e r s b = n e w
sb. replace (4, 8, "был") ; System.out.println("Пocлe
тест.");
применение
StringBuffer("Этo простой
замены:
" + s b ) ;
один набор
другим
символов

 зиции
Глава 17. Обработка символьных строк 557 Ниже приведен результат, выводимый данной проrраммой.
После замены: Это был тест.
Метод substring ()
Вызвав метод s u b s t r i n g (),можно получить часть содержимоrо объекта типа
StringBuffer. У этоrо метода имеются две следующие формы: String substring(int начальный_индекс)
S t r i n g s u b s t r i n g ( i n t начальный_индекс, i n t конечный_индекс)
В первой форме этот метод возвращает подстроку, которая начинается с по­
на чальный_индекс
и
StringBuffer appendCodePoint
Присоединяет кодовую точку в Юникоде
( i n t
int codePointAt(int i)
int codePointBefore(int i) int codePointCount
символ)
i n t indexOf(String
( i n t начало, int
конец)
int
int начальный_индекс)
indexOf(String
строка,
Выполняет поиск в вызывающем объекте типа
int lastindexof (String C!I'pOKa)
Выполняет поиск в вызывающем объекте типа
С!I'рока)
продолжается до
типа StringBuffer. А во второй форме он возвращает подстроку от позиции начальный_индекс и до позиции конечный_индекс-1. Эти формы метода s u b s t r i n g () действуют таким же образом, как и рассмотренные ранее их анало­ rи из класса String.
Дополнительные методы из класса StringBuffer Помимо описанных выше методов, класс S t r i n g B u f f e r содержит ряд друrих
методов, включая и перечисленные в табл. 17.3.
Таблица 17.З. Дополнительные методы из класса S t r i n g B u f f e r
llJl181
конца
в конце вызывающеrо объекта. Возвращает
ссылку на объект
Возвращает кодовую точку в Юникоде
на позиции i
Возвращает кодовую точку в Юникоде
на позиции, предшествующей i
Возвращает количество кодовых точек в части
вызывающей строки от позиции начало и до
позиции конец-1
Выполняет поиск в вызывающем объекте типа
StringBuffer первоrо вхождения строки. Возвращает индекс позиции при совпадении,
а
иначе -
- 1
значение
StringBuffer первого вхождения С!I'рокя,
начиная с позиции начальный
индекс.
а
- значение
- 1
Возвращает индекс позиции прИсовпадении,
иначе
StringBuffer последнего вхождения С!I'рОКИ. Возвращает индекс позиции при совпадении,
а
иначе -
- 1
значение
вызывающеrо
объекта

 558 Часть 11. Библиотека Java
Метод
int lastindexOf (String C!l'pOKa,
Выполняет поиск в вызывающем объекте типа
i n t
индекс.
начальный_индекс)
начиная с позиции начальный
int offsetByCodePoints
Возвращает индекс символа в вызывающей
( i n t
начало, i n t
число)
CharSequence subSequence
Возвращает подстроку из вызывающей строки,
( i n t начальный
i n t конечный- индекс)
void trimToSize()
Требует, чтобы размер символьного буфера
индекс,
StringBuffer sb = new StringBuffer("one two one"); int i;
i sb.indexOf{"one"); System.out.println("Индeкc
" +
i ) ;
i = sb.lastindexOf("one");
System.out.println("Индeкc последнего вхождения: "
Эта программа выводит следующий результат:
Индекс первого вхождения: О
Индекс последнего вхождения: 8
Класс StringBuilder
+ i);
а
иначе -
- 1
Описание
StringBuffer последнего вхождения С!l'роки,
Возвращает индекс позиции прИсовпадении,
строке, который
отстоит на
значение
кодовых точек от начального индекса,
определяемого параметром начало
начиная с позиции начальный
и оканчивая позицией конечнЫй
индехс. Этот
метод требуется для интерфейса C h a r S e q u e n c e , реализуемого в классе StringBuffer
вызывающего объекта был уменьшен
для большего соответствия текущему
содержимому
В следующем примере программы демонстрируется применение методов
indexOf () и lastindexOf ().
class IndexOfDemo {
puЬlic static void main(String args[]) {
первого
Класс StringBuilder ничем не отличается от класса StringBuffer, за ис­ ключением того, что он не синхронизирован, а следовательно, не является пото­ кобезопасным. Применение класса StringBuilder дает выигрыш в производи­ тельности. Но в тех случаях, когда обращение к изменяемой строке происходит из нескольких потоков исполнения без внешней синхронизации, следует применять класс StringBuffer, а не StringBuilder.
вхождения:
Окончание табл. 11.З
заданное
индекс
число

 ГЛАВА
 18
Эта глава посвящена классам и интерфейсам, определенным в пакете
j ava. lang. Как вам должно быть уже известно, пакет j ava. lang автоматически импортируется во все программы. Он содержит классы и интерфейсы, которые составляют основу всех программ на Java. Пакет j ava. lang наиболее широко ис­ пользуется в Java. Начиная с версии JDK 9, пакет j ava. lang полностью входит в состав модуля j ava. base. Этот пакет включает в себя следующие классы.
Boolean Float
Process StrictMath ProcessBuilder String
ProcessBuilder. StringBuffer Redirect
Runtime StringBuilder
Byte
Character Integer
Character.Subset Long
InheritaЫe
ThreadLocal
Пакет j ava. lang
Character. Module Runtime.Version System UnicodeBlock
Class
ClassLoader
ClassV alue compiler DouЫe
Enum
ModuleLayer RuntimePermission System. LoggerFinder
ModuleLayer. SecurityManager Thread Controller
Math Short ThreadGroup NumЬer StackтracePermission ThreadLocal Object StackTraceElement Throwable Package StackW alker V oid
Ниже перечислены интерфейсы, определенные в пакете j ava. lang.
AppendaЬle IteraЫe
StackWalker.StackFrame
System.Logger
CharSequence ProcessHandle.Info Thread.UncaughtExceptionHandler
AutoCloseaЬle Processнandle
CloneaЫe
ComparaЫe
ReadaЬle
RunnaЫe
j a v a . l a n g , содержат устарев­ шие методы, большинство из которых относится еще к версии Java 1.0. Эти методы
Некоторые
классы, входящие
в
состав
пакета

 560 Часть 11. Библиотека Java
все еще предоставляются в Java для поддержки постепенно выводимого из экс­ плуатации унаследованного кода и не рекомендуются для употребления в новом коде. Поэтому не рекомендованные к употреблению методы в этой главе не рас­ сматриваются.
Оболочкипримитивныхтипов
Как упоминалось в части 1, примитивные типы данных вроде int и char при­ меняются в Java из соображений производительности и не являются частью объ­ ектной иерархии. Они передаются методам по значению и не могут быть переданы им по ссылке. Кроме того, из двух методов нельзя ссылаться на один и тот же эк­ земпляр типа int. Но рано или поздно возникает потребность в объектном пред­ ставлении одного из примитивных типов данных. Например, существуют классы коллекций, предназначенные для обращения только с объектами (они обсуждают­ ся в главе 19). Чтобы сохранить примитивный тип данных в одном из таких классов, следует заключить в него этот примитивный тип. И для того чтобы удовлетворить потребность в этом для каждого примитивного типа данных, в Java предоставля­ ется отдельный класс, обычно называемый оболочкой типа. Оболочки типов были представлены в главе 12, а здесь они рассматриваются более подробно.
Класс NumЬer
N u m b e r
в классах оболочек числовых типов byte, short, int, long, float и douЫe.
В классе Number имеются абстрактные методы, возвращающие значение объекта в разных числовых форматах. Например, метод douЬleValue ( ) возвращает зна­
Абстрактный
класс
является
суперклассом,
который
реализуется
чение типа douЬle, а метод floatV alue () - методы перечислены ниже.
byte byteV alue ()
douЫe douЬleValue()
float floatV alue() int intValue() long longV alue() short shortV alue()
значение типа float и т.д. Все эти
Значения, возвращаемые этими методами, могут быть округлены, усечены
или собраны в "мусор" вследствие сужающего преобразования. У класса Number имеются конкретные подклассы, содержащие явные значения каждого числового типа: DouЫe, Float, Byte, Short, Integer и Long.
Классы DouЫe и Float
Эти классы служат оболочками для числовых значений с плавающей точкой типа
douЫe и f loat соответственно. Ниже приведены конструкторы класса Float.

 Float(douЫe число)
Float(float число)
Float(String строка) throws NumЬerFormatException
Как видите, объекты типа Float должны быть созданы со значениями типа f l оаt или douЫ е. Они могут также быть созданы из строкового представления числа с плавающей точкой. Начиная с версии JDK 9, эти конструкторы не реко­ мендуются к употреблению. А в качестве их альтернативы рекомендуется метод valueOf ().
Ниже приведены конструкторы класса DouЫe.
DouЬle(douЫe число)
строка) t h r o w s
Объекты типа DouЫe могут быть созданы из значения типа douЫe или сим­
вольной строки, содержащей значение с плавающей точкой. Начиная с версии
JDK 9, эти конструкторы не рекомендуются к употреблению. А в качестве их аль­ тернативы используется метод valueOf ().
DouЬle(String
NumЬerFormatException
Методы, определенные
в
классе
перечислены
в табл.
18.1, а
методы,
определенные в классе DouЬle, -
ляются следующие константы.
BYTES
ИAX_EXPONENT
ИAX_VALUE
MIN_EXPONENT
Длина числового типа f l o a t или douЫe в байтах Максимальный показатель степени
Максимальное положительное значение Минимальный показатель степени
Минимальное положительное нормальное значение
Минимальное положительное значение
MIN_NORМAL
MIN_V ALUE NaN
Не число
Положительная
P O S I T I V E
INFINIТY
бесконечность
NEGATIVE_INFINIТY
SIZE
Отрицательная бесконечность
Размер заключенного в оболочку значения в битах
-
Объект типа Class для числовых типов float и douЬle Таблица 1 8 . 1 . Методы из класса F l o a t
ТУРЕ
Метод
byte byteV alue() static int compare
( f l o a t
float число)
int compareтo (Float f)
Описание
Возвращает значение вызывающего объекта как тип byte
Сравнивает значения vясло и чясло • Возвращает
Глава 18. Пакетjava.lang 561
F l o a t ,
в табл. 18.2. В классах F l o a t и DouЫe опреде­
 VJl.CЛOJ,
нулевое
значение, если
сравниваемые
числовые
значения
равны; отрицательное значение, если vясло меньше, чем
12
1
чясло ; или положительное значение, если vясло
21
чем чясло
2
Сравниваетчисловоезначениевызывающегообъекта
созначениемf.Возвращаетнулевоезначение,если сравниваемые числовые значения равны; отрицательное значение, если вызывающий объект имеет меньшее значение; или положительное значение, если вызывающий объект
имеет большее значение
больше,

 562
Часть 11. Библиотека Java
equals (Object FloatObj)
static int floatTointBits (float число)
static int
floatToRawintБits
( f l o a t число)
float floatV alue()
int hashCode()
static int hashCode (float число)
static float
intвitsToFloat
( i n t
int intValue() Ьoolean isinfinite()
s t a t i c Ьoolean isinfinite
(float число)
Ьoolean
число)
точности,
определяемой
параметром
число
Возвращает значение вызывающего объекта как тип i n t Возвращает логическое значение true, если вызывающий
объект содержит бесконечное значение, а иначе - значение false
Возвращает логическое значение t r u e , если число
логическое
определяет бесконечное значение, а иначе - значение false
логическое
Продолжениетабл. 18.1
 douЫe
douЫeValue()
Возвращает значение вызывающего объекта как тип douЫe
Возвращает логическое значение true, если вызывающий объекттипаFloatравенобъектуFloatObj,аиначе- логическое значение false
Возвращает совместимую со стандартом IEEE комбинацию двоичных разрядов одинарной точности, соответствующую заданному числу
Возвращает совместимую со стандартом IEEE комбинацию двоичных разрядов одинарной точности, соответствующую заданному числу. Значение NaN не допускается
Возвращает значение вызывающего объекта как тип f l o a t Возвращает хеш-код вызывающего объекта
Возвращает хеш-код заданного числа
Возвращает эквивалент типа f l o a t совместимой со стандартом IEEE комбинации двоичных разрядов одинарной
Ьoolean
isNaN ( )
Возвращает логическое значение true, если вызывающий
static Ьoolean
Возвращаетлогическоезначениеtrue,есличисло
i s N a N ( f l o a t
число)
определяет
нечисловое
значение,
а
иначе -
логическое
long longV alue()
s t a t i c f l o a t max(float val1 , float val2)
значение false
Возвращает значение вызывающего объекта как тип long Возвращает наибольшее из двух значений v a l 1 и v a l 2
Возвращает наименьшее из двух значений val1 и val2
static (float float
static parseFloat(String C'l'poxa) throws NUmЬerFormatException
short shortV alue()
static f loat sum (float val1,
float val2)
float min
val1, val)
f l o a t
Возвращает
эквивалент
числа типа
f l o a t ,
содержащегося
объект содержит нечисловое значение, а иначе - значение false
логическое
в C'l'pOICe, по основанию 1О
Возвращает значение вызывающего объекта как тип short Возвращает результат сложения значений val1+val2

  Метод
Глава 18. Пакетjava.lang 563 Окончаниетабл. 18.1
Возвращает символьную строку, содержащую число
в шестнадцатеричном формате
Возвращает строковый эквивалент вызьmающего объекта
Возвращает строковый эквивалент значения, определяемого
параметром число
Возвращает объекттипа Float, содержащий значение, передаваемое в качестве параметра число
ВозвращаетобъекттипаFloat,содержащийзначение, указанное в заданной C!rpoxe
s t a t i c S t r i n g toHexString
(float число)
S t r i n g t o s t r i n g ( )
s t a t i c S t r i n g toString(float чмсло)
static (float
Float valueof
число)
static
(String C!rpOXa)
Float valueof
throws NUmЬerFoпnat Exception
Таблица 18.2. Методы из класса DouЫe
Описание
 Метод
byte byteV alue () static int compare
(douЫe число , 1
douЫe число )
i n t
(DouЬle d )
static long
douЫeToLongBits
(douЫe чмсло)
s t a t i c l o n g
douЬleToRawLongBits
compareтo
(douЫe
douЫe
boolean
(Object DouЬieObj)
float floatV alue()
int hashcode()
static int hashCode
(douЫe чмсло)
int intValue() boolean isinfinite()
со значением d Возвращает нулевое значение, если сравниваемые числовые значения равны; отрицательное значение, если вызывающий объект имеет меньшее значение; или положительное значение, если вызывающий объект имеет большее значение
Возвращает совместимую со стандартом IEEE комбинацию двоичных разрядов двойной точности, соответствующую заданному числу
Возвращает совместимую со стандартом IEEE комбинацию двоичных разрядов двойной точности, соответствующую заданному числу. Значение NaN не допускается
Возвращает значение вызывающего объекта как тип douЫe
Возвращаетлогическое значение true, если вызывающий объекттипаDouЬleравенобъектуDouЬieObj,аиначе- логическое значение false
Возвращает значение вызьmающего объекта как тип f l o a t Возвращает хеш-код вызывающего объекта
Возвращает хеш-код заданного чмсла
Возвращает значение вызьmающего объекта как тип i n t
Возвращает логическое значение t r u e , если вызьmающий объект содержит бесконечное значение, а иначе - логическое значение false
число)
douЬleValue()
equals
Описание
Возвращает значение вызывающего объекта как byte Сравнивает значения число и число • Возвращает
12
нулевое значение, если сравниваемые числовые значения
равны; отрицательное значение, если число меньше, чем
21
чмсло ; или положительное значение, если число больше,
21
чем число
2
Сравнивает числовое значение вызьmающего объекта
·

 564 Часть 11. Библиотека Java
static boolean i s i n f i n i t e
(douЫe число) boolean isNaN ( )
static boolean
isNaN(douЫe число)
static douЫe longBitsToDouЬle
( l o n g число)
long longV alue()
static douЫe max (douЫe val1,
douЫe val)
static douЫe min (douЫe val1,
douЫe val)
static douЫe parseDouЫe(String с~ожа) throws NumЬerFormatException
short shortV alue()
Возвращает логическое значение true, если чжсло
определяет бесконечное значение, а иначе - значение false
логическое
Возвращает логическое значение true, если вызывающий
объект содержит нечисловое значение, а иначе - значение false
логическое
Возвращает логическое значение true, если чмсло определяет нечисловое значение, а иначе - логическое значение false
ВозвращаетэквиваленттипаdouЬleсовместимойсо
стандартом IEEE комбинации двоичных разрядов двойной
Окончаниетабл. 18.2
 static douЫe (douЫe val1, douЫe val2)
s t a t i c S t r i n g toHexString
sum
Возвращает значение вызывающего объекта как тип long Возвращаетнаибольшееиздвухзначенийval.1 иval.2
Возвращаетнаименьшееиздвухзначенийval1иval.2
ВозвращаетэквивалентчислатипаdouЫe,содержащегося
в с~оже, по основанию 10
Возвращает значение вызывающего объекта как тип short Возвращает результатсложения значений val.1+val2
Возвращает символьную строку, содержащую чмсло
